import socket

class Socket(socket.socket):
    def __init__(self, address_family: socket.AddressFamily, 
                 socket_type: socket.SocketKind):
        super().__init__()
        self.socket = socket.socket(address_family, socket_type)
        # allows reusage of IP address (I think), otherwise kept getting OSError
        # if connected to server from terminal on same device
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.ip: str = self.get_ip()
        self.af = address_family
        self.sock_type = socket_type
    
    @staticmethod
    def convert_list_to_bytes[T: str | int | bytes | list[str | int | bytes]]\
            (to_send: list[str | bytes | int | list[T]], separators: list =
            ["/", "::", ":"], recursion_level: int = 0) -> bytes | str:
        """
        converts a list to a string with predefined separators denoting nested lists.
        
        the separators list has to be the most specific at the top level -
        for example, :: has to be higher up than :
        """
        for index, item in enumerate(to_send):
            if isinstance(item, list):
                to_send[index] = Socket.convert_list_to_bytes(item, separators[1:], 
                                                            recursion_level + 1)
            elif not isinstance(item, str):
                to_send[index] = str(item)
        if recursion_level == 0:
            # converts the list to bytes if at top recursion level
            joined = separators[0].join(to_send).encode()
        else:
            joined = separators[0].join(to_send)
        
        return joined
    
    @staticmethod
    def convert_bytes_to_list(received: bytes, separators: list[str] = ["/", "::", ":"]) -> list[str | int | list[str | int]]:
        """
        decodes bytes to a list based ond predefined separators that denote nested lists.
        """
        decoded: str = received.decode()
        split:list[str | int | list[str | int]] = decoded.split(separators[0])
        for index in range(len(split)):
            if split[index].isdigit():
                split[index] = int(split[index])
            elif separators[1] in split[index]:
                split[index] = Socket.convert_bytes_to_list(split[index], separators[1:])
        return split

    def get_ip(self) -> str:
        """
        this function connects the dgram socket to google,
        thus returns the router IP.
        """
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        IP = s.getsockname()[0]
        s.close()
        return IP
    
    def assign_clients(self, addresses):
        """
        put address list into a clients attribute.
        """
        # deepcopy because list is later modified
       
        self.clients = addresses[:self.player_no] + addresses[self.player_no + 1:]
        for i in range(len(self.clients)):
            self.clients[i] = tuple(self.clients[i])
        print(f"Client list: {self.clients}")
